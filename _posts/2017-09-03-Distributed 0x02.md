---
layout: page
title: Distributed 0x02
tags: [Distributed]
excerpt_separator: <!--more-->
typora-root-url: ../
---



## Distributed 0x02



### 分布式互斥

  分布式系统中，Concurrency是很重要的一个部分。任务在不同的进程中执行时，不可避免的会遇到访问相同的资源，这种情况下，就需要保证并发访问情况下的准确性的解决方案。 通常情况下，分布式互斥两种基本的策略[1]：

1. 基于令牌的算法(token-based)；
2. 基于许可的算法(permission-based)；

 在基于令牌的算法中，所有的进程共享一个token，只有拥有token的进程才可以进入临界区，当临界区执行完之后，token被释放。token的唯一性保证了互斥，死锁也可以简单的被避免，不过一个问题时处理token丢失比较麻烦。对于基于许可的算法，一个进程要到达所有进程的一个子集的允许后才能进入临界入区。一个互斥的算法应该满足下面几个基本的要求[2]：

        1. 安全性：如何情况下只能有一个进程能够进入临界区；
        2. 活性：不存在死锁和饥饿，每个进程会在有限的时间了得到临界区的机会；
        3. 公平性：每个进程得到执行临界区的机会时公平的(一般是指执行临界区的顺序是按照它们请求执行临界区的逻辑时间的先后顺序)。

  除了基本的要求之外，对于一个分布式互斥的算法性能也是很重要的:
        1. 进去临界区需要发送消息的数量；
        2. 同步延时，从一个节点离开临界区到下一个节点进入需要的时间；
        3. 响应时间，一个请求消息发出到请求的临界区执行结束的时间；
        4. 系统吞吐量，系统执行临界区请求的速度，等于同步延时+平均临界区执行时间的倒数；



#### 中央服务器算法

  基于中央服务器的算法是一个简单有效的方法。最基本的思路是使用一个进程作为协调人。如果一个进程要执行临界区，它得向协调人请求，协调人在没有在其它的进程使用临界区的情况下就会授予改进程使用临界区的权限，否则将会拒绝请求，在进程执行完临界区之后，将会发送信息告知协调人释放临界区的锁。
  这个算法的基本思路很简单，也很实用，现在实际使用的很多相关的系统也是使用了这个模型，比如Google Chubby[3]、Zookper[4]。但是要具体实现还要解决很多的问题，比如进程在临界区内Crash，协调人如何保证可靠性等等，具体可以参考[3，4]。



#### 令牌环的算法

  基于令牌的算法以及令牌环的思路在网络中的一些协议也很常见。在这个算法中，所有的进程被组织位一个逻辑上的环。环上的进程被丛0开始依次编号，初始化时，token个授予编号为0的进程，token在环中由k进程传递到k+1进程(最后一个传回0号进程)。如果一个进程需要执行临界区，需要得到token被传递给它时，将token保留到它执行完临界区，如果进程不对token感兴趣，只需要简单地将token传递给下一个进程即可。
​    因为任何时间，最多有一个进程拥有token，使用互斥时包保证的。改算法也不会导致死锁。该算法也存在不少的问题，第一个就时token丢失的问题，token在传递的过程中可能被丢失，一个在一个持有token的进程在执行临界区时Crash也会造成token丢失。另外一个问题时环中的进程Crash会阻碍token的传递。



### 基与组播和逻辑时钟的算法

#### Lamport算法

 Lamport发明的这种分布式互斥的算法时一种时间同步机制[2]，它要求通信时FIFO的。该算法具体表现为
        1. 当一个节点S(i)想进入临界区时，它广播REQUEST(ts(i),i)的消息给其它的所有节点，并将改请求放置到request queue(i)队列；
        2. 当其它的节点S(j)说到这个消息时，它将S(i)的请求放置到request-queue(j)的队列，并恢复一个带时间戳的REPLY消息。当下面两个条件满足时，S(i)进入临界区:
           * S(i)从其它的所有站点收到一个时间戳大于（ts(i),i)的消息；
           * 节点S(i)的请求位于request-queue(i)的队首。
        3. 当S(i)执行完临界区后，从自己的请求队列删除自己的请求，并广播一个带时间戳的释放消息给其它节点。
        4. 其它节点收到后释放消息，从自己的request-queue删除S(i)的请求。



#### Ricard-Agrawala 算法

  这个算法可以看作是上个算法的一个改良版本[1]，也是通过发送向其它节点REQUEST消息来请求进入临界区的许可，通过回复REPLY来表示通过请求。
  当节点S(j)收到S(i)的REQUEST的消息时，如何当前没有在请求执行临界区 or 在执行临界区，或者虽然S(j)在请求执行临界区，但是时间戳比S(i)的这次请求的要大，就回复S(i)REPLY消息，否则，延迟发送REPLY消息。
  S(i)在收到所有节点的REPLY消息时，进入临界区。执行完毕后，S(i)发送所有延迟的REPLY消息。

  相比于上面的Lamport算法，改算法使用了延时发送的方法。这个方法减少了需要发送消息的数量，提高了性能。



#### 总结

  这里简单的介绍了集中分布式互斥的算法，除此之外，更多的分布式互斥的算法在书[1,2]有更详细的描述。此外，这些算法和实际总工程中使用的分布式互斥的方法还是有很大的区别的。对于在实际工程中使用的分布式互斥的方法，[3,4]是非常好的参考。



### 全局状态与快照

  在没有共享存储器和全局时钟的分布式系统之中有效的纪录系统的全局状态很重要但也不是一件简单的事情。系统全局状态在死锁检测，故障恢复等方面都有很重要的作用。
  分布式系统的全局状态是进程和通道本地状态的集合，使用符号GS表示[1]。分布式系统中的一致性快照需要处理一下的两个问题:

1. 如何判别纪录在快照中的消息和没有在快照中的消息，要求:
   *  在纪录快照之前的一个进程发送的消息一定都会被记录在全局快照之中；
   *  在纪录快照之后的一个进程发送的消息一定都不会被记录在全局快照之中。

2. 如何确定快照的瞬间。



#### FIFO通道: Chandy - Lamport 算法

  Chandy - Lamport 算法算法假设通信的通道是FIFO的和可靠的，它使用了一个称为标记的控制信息。算法主要由两个部分组成: 标记发送规则和标记接收规则。消息一个进程在记录完它自己的快照之后，向其它所有的进程发送一个标记，这个被称为标记发送规则。因为通信通道是FIFO的，使用标记将在快照之前的消息标示出来，这样可以满足上面的第1点。
  一个进程在接受到来自一个通道C标记之后，如果它还没有记录自身的状态，则记录接受到标记的通道C的状态为空，并执行上面描述的的标记发送规则。如果已经接受到C的标记，则记录C的状态记录为在该通道上记录了本地状态之后且在接受标记之前的消息的集合。

 算法的过程如下[1，2]:

1. 进程p的标记发送规则:1.  进程p记录本地状态；2.  对其它进程发送标记。

2. 进程p的标记接收规则: 进程p在通道C接收到标记后，如何p没有记录自身的状态，则记录C的状态为空并执行标记发送规则，否则，记录C的状态为消息集。算法在进程p接收到来自所有输入通道的标记之后终止。


#### Variants

以Chandy - Lamport算法为基础，再次之上有多种算法的变种。Spezialetti - Kearns 算法主要在快照收集的并发启动和被记录快照的有效发送。在一些系统之中，会定期的收集系统的全局快照，Venkatesan快照增量算法优化了这种情况，Venkatesan快照增量算法将上一次获取的快照和记录最后一次快照以来的增量快照结合在一起，形成目前的系统快照。



#### 应用

  Flink中的创建快照的算法[4]主要收到了Chandy - Lamport算法的启发。在Flink中，为了容错，使用了Checkpoint的机制，在错误发生之后恢复错误时，可以恢复到获取的某个Checkpoint，对于具体细节的描述，可以参考Flink的相关资料。



#### 非FIFO通道

  在FIFO的通道中，Chandy - Lamport 算法的标记很好的区分了快照之前的消息和快照之后的消息。但是在非FIFO的通道之中，这种办法就想不通了。 为了实现和Chandy - Lamport 算法区分消息的效果，Lai - Yang算法使用了着色的方法，方法如下: 每个进程开始的时候是白色的，拍快照的时候变成了红色，对应的白色的(红色的)消息就是拍快照前(后）发送的消息；每个白色进程在合适的时刻拍下自己的快照，这个时刻不应该晚与接收到一个红色消息的瞬间。



## 参考

1. 《Distributed Systems: Principles and Paradigms》第二版，ISBN: 0-13-239227-5。
2. 《分布式计算 -- 原理、算法与系统》，ISBN: 978-7-04-032456-3
3. The Chubby lock service for loosely-coupled distributed systems, OSDI'06.
4. Zookeeper: Wait-free coordination for Internet-scale systems, ATC'10.
