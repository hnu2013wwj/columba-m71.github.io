<!DOCTYPE html>
<html lang="en-us">

<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <link rel="stylesheet" href="/assets/css/normalize.css"/>
  <link rel="stylesheet" href="/assets/css/bulma.css"/>
  <link rel="stylesheet" href="/assets/css/custom.css"/>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <!-- <link href="https://fonts.googleapis.com/css?family=Open+Sans|Roboto" rel="stylesheet"> -->

  <!-- Icons -->
  <link rel="shortcut icon" href="/assets/images/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <title>
    
      Storage & Recovery Methods for NVM DB &middot; Columba M71's Blog
    
  </title>

</head>


<body>

<section class="hero is-dark">
  <div class="hero-body">
    <div class="container">
        <h1 class="title">
          <span class="typewrite" data-period="2000" data-type='[ "Columba M71"]'>
            <span class="wrap"></span>
          </span>
        </h1>
      <h4 class="subtitle" id="quote">
      </h4>
    </div>
  </div>
</section>

<div class="main-container">
  <div class="tile is-ancestor is-vertical">


    <nav class="nav has-shadow">

      <div class="nav-left">

        <a href="/" class="nav-item">
          <span class="icon">
            <i class="fa fa-home" aria-hidden="true" title="Homepage"></i>
          </span>
        </a>

        <a href="https://github.com/hnu2013wwj" class="nav-item">
          <span class="icon">
            <i class="fa fa-github" aria-hidden="true" title="Github"></i>
          </span>
        </a>

        <div class="nav-item" id="searchFieldNav">
          <div class="field has-addons">
            <p class="control">
              <input class="input is-small" type="text" placeholder="Find an article" id="search-text">
            </p>
            <p class="control">
              <a class="button is-dark is-small" onclick="searchHandler();">
                Search
              </a>
            </p>
          </div>
        </div>

      </div>

      <div class="nav-right nav-menu" id='nav-menu'>
        <a href="/archive" class="nav-item">Archive</a>
        <a href="/tags" class="nav-item">Tags</a>
      </div>

      <span class="nav-toggle" id="nav-toggle">
          <span></span>
          <span></span>
          <span></span>
    </nav>

    <div class="tile is-parent">
      <div class="tile is-8 is-child main">

        <div class="box">
    <h1 class="post-title">Storage & Recovery Methods for NVM DB</h1>
    <hr/>
    <div class="content"><span class="post-text"><h2 id="lets-talk-about-storage--recovery-methods-for-non-volatile-memory-database-systems">Let’s Talk About Storage &amp; Recovery Methods for Non-Volatile Memory Database Systems</h2>

<h3 id="引言">引言</h3>

<p>这篇Paper主要讨论了数据库的不同类型的存储和恢复方式在NVM上的表现。NVM有着不同于DRAM和SSD的性能特点，自然不同的方式在NVM也有着不同的性能体现。Paper主要讨论了常见的就地更新，Copy-on-Write和 Log-structured Updates在NVM为基础的数据库上的各种的表现。</p>

<h3 id="分类">分类</h3>

<p>基本分类：</p>

<p><img src="/assets/img/nvm-sr-types.png" alt="nvm-sr-types" /></p>

<h4 id="in-place-updates-engineinp">In-Place Updates Engine(InP)</h4>

<p>InP是数据库中常见的存储策略，更新数据时就直接在原来的数据上进行。</p>

<h5 id="storage">Storage</h5>

<p>在InP engine 中，存储空间被分为一些固定长度的blocks，和一些变长的blocks。这两个不同用于存储不同的数据。每一个block由一组slot组成，tuple被保存在这些slot里面，超过8byte的字段被保存在变长的slot里面，原tuple对应的字段的位置就保存地址信息。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>When a transaction inserts a tuple into a table, the engine first checks the table’s pool for an available slot. If the pool is empty, then the engine allocates a new fixed-size block using the allocator interface. The engine also uses the allocator interface to maintain the indexes and stores them in memory.
</code></pre></div></div>

<h5 id="recovery">Recovery</h5>

<p>​    由于在最后一个检查点之前提交的数据时不能保证已经持久化保存了，使用InP使用常见的WAL来解决持久化的问题。最常见的WAL类型就是ARIES。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> The InP engine uses a variant of ARIES that is adapted for main memory DBMSs with a byte-addressable storage engine. As we do not store physical changes to indexes in this log, all of the tables’ indexes are rebuilt during recovery because they may have been corrupted.
</code></pre></div></div>

<p>.</p>

<blockquote>

</blockquote>

<h4 id="copy-on-write-updates-engine-cow">Copy-on-Write Updates Engine (CoW)</h4>

<p>CoW类型的策略时从来步更新原来的数据，只会在原来的基础上创建一个新的数据。CoW引擎使用directories 的方式访问不同版本的数据，常见的例子就是System R上面的影子页。CoW中存在一个Master记录，用于保存目前的directories的信息，基本的组织方式上面的图有很好的说明：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>the DBMS maintains two look-up directories at all times: (1) the current directory, and (2) the dirty directory. The current directory points to the most recent versions of the tuples and only contains the effects of committed transactions. The dirty directory points to the versions of tuples being modified by active transactions.
</code></pre></div></div>

<p>txn提交的时候，DB原子地将指向原来master版本的改为指向新的版本。为了解决拷贝的成本，可以使用 copy-on-write B+trees。</p>

<h5 id="storage-1">Storage</h5>

<p>​    CoW将directories保存在FS中，可以以一种HDD/SSD优化的给出存储，将所有的字段都内联。这样可以避免昂贵的随机访问操作。每一个数据库(表)都保存在一个单独的文件里面，Master记录总是在文件固定偏移的地方。通过使用映射到主键的方式，CoW支持次级索引。</p>

<p>CoW的缺点就是每次会创建新的数据拷贝，即使只是更新了部分数据。此外，垃圾回收也是一个问题。多次拷贝也带了了写操作放大的问题。</p>

<h5 id="recovery-1">Recovery</h5>

<p>CoW的方式恢复很简单，如果Master记录在没有改变之前数据库就Crash了，不需要做恢复的处理。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>When the DBMS comes back on-line, the master record points to the current directory that is guaranteed to be consistent. The dirty directory is garbage collected asynchronously, since it only contains the changes of uncommitted transactions.
</code></pre></div></div>

<h4 id="log-structured-updates-engine-log">Log-structured Updates Engine (Log)</h4>

<p>Log的方式来自log-structured文件系统。Log方式使用LSM-tree。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The design for our Log engine is based on Google’s LevelDB, which implements the log-structured update policy using LSM trees.
</code></pre></div></div>

<h5 id="storage-2">Storage</h5>

<p>数据存储使用了LSM tree，这个就不细说了.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The log-structured update approach performs well for write-intensive workloads as it reduces random writes to durable storage. The downside of the Log engine is that it incurs high read amplification (i.e., the number of reads required to fetch the data is much higher than that actually needed by the application).
</code></pre></div></div>

<h4 id="recovery-2">Recovery</h4>

<p>Log方式恢复的方法就是从WAL重建MemTable。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>It first replays the log to ensure that the changes made by committed transactions are present. It then removes any changes performed by uncommitted transactions, thereby bringing the MemTable to a consistent state.
</code></pre></div></div>

<p>.</p>

<blockquote>

</blockquote>

<h3 id="nvm-aware-engine">NVM-Aware Engine</h3>

<p>上面提到的存储恢复方式都是为了DARM + HHD/SSD的存储层级结构设计的，在NVM上面有应该怎么样优化呢？</p>

<p>一个基本的表示图，注意和上面的图的区别:</p>

<p><img src="/assets/img/nvm-sr-nvm-aware.png" alt="nvm-sr-nvm-aware" /></p>

<h4 id="in-place-updates-engine-nvm-inp">In-Place Updates Engine (NVM-InP)</h4>

<p>InP存在的一个问题就是数据重复比较多，比如数据被更新一次就会向WAL中写入一次，然后在向table存储区域中写入一次。当然，在原来的系统中这么设计时必须的。但是在NVM中，因为在NVM中，数据一旦写入到table存储区域中，数据就被持久化了，没有之前系统中不保证持久化的问题。</p>

<p>所以在NVM-InP中，WAL中只会记录指向tuple的指针。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Thus, the engine can use the pointer to access the tuple after the system restarts without needing to re-apply changes in the WAL. It also stores indexes as non-volatile B+trees that can be accessed immediately when the system restarts without rebuilding.
</code></pre></div></div>

<h5 id="storage-3">Storage</h5>

<p>存储方式和InP的方式基本一样，存储空间被分为一些固定长度的blocks，和一些变长的blocks。这两个不同用于存储不同的数据。每一个block由一组slot组成，tuple被保存在这些slot里面。做出的一些改变就是每一个slot都被加了一个状态标记，用于垃圾回收:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>To reclaim the storage space of tuples and non-inlined fields inserted by uncommitted transactions after the system restarts, the NVM-InP engine maintains durability state in each slot’s header. A slot can be in one of three states - unallocated, allocated but not persisted, or persisted. After the system restarts, slots that are allocated but not persisted transition back to unallocated state.
</code></pre></div></div>

<p>NVM-InP将WAL组成成一个非易失的list，新提交的就直接接到list的尾部。 系统必须在WAL的一项持久化之后才能更改slot的状态。</p>

<h5 id="recovery-3">Recovery</h5>

<p>​    NVM-InP只需要处理没有提交的事务就可以了，不用重放Log。由于没有提交的txn并不能保证数据已经被持久化到NVM上面了，所以NVM-InP需要做undo的处理。方法就是使用WAL里面的消息恢复指向以前数据的指针，此外还要释放相关的NVM空间。对于删除操作，只需要修改索引的指针指向原来的数据即可。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>To handle transaction rollbacks and DBMS recovery correctly, the NVM-InP engine releases storage space occupied by tuples or non-inlined fields only after it is certain that they are no longer required. 
</code></pre></div></div>

<p>这里可以看到， NVM-InP revery是没有redo处理过程的。</p>

<blockquote>

</blockquote>

<h4 id="copy-on-write-updates-engine-nvm-cow">Copy-on-Write Updates Engine (NVM-CoW)</h4>

<p>NVM-CoW的优化点在于：</p>

<ul>
  <li>使用一种使用分配器接口的non-volatile copy-on-write B+tree(用一个类似使用内存的方式，之前的方式的 copy-on-write B+tree是保存在文件系统里面的，也就只能利用文件的方式).</li>
  <li>直接持久化tuple副本，只在dirty directory保留tuple的指针；</li>
  <li>使用一种轻量化的持久化的机制来持久化 copy-on-write B+tree的更改。</li>
</ul>

<h5 id="storage-4">Storage</h5>

<p>类型NVM-InP 的方式，存储空间被分为一些固定长度的blocks，和一些变长的blocks。相关的copy-on-write B+tree也保存在NVM中，不在保存到文件系统里面。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>We modified the B+tree from LMDB to handle modifications at finer granularity to exploit NVM’s byte addressability. The engine maintains the master record using the allocator interface to support efficient updates. When the system restarts, the engine can safely access the current directory using the master record because that directory is guaranteed to be in a consistent state.
</code></pre></div></div>

<h5 id="recovery-4">Recovery</h5>

<p>不需要处理Recovery，只需要异步地将没有提交的数据回收即可。这个是最有趣的了。</p>

<blockquote>

</blockquote>

<h4 id="log-structured-updates-engine-nvm-log">Log-structured Updates Engine (NVM-Log)</h4>

<p>同样，类似前面的，在WAL中只保留指向tuple的指针。MemTable也不用在flush在磁盘上面，只需要标记为不可变然后开启一个新的MemTable就可以了。也优化了compaction的策略，一次性可以合并多个。</p>

<h5 id="storage-5">Storage</h5>

<p>这里没有MemTable和SStable的区别，只是不同level和可变不可变的区别。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Like the NVM-InP engine, this new engine also stores the WAL as a non-volatile linked list of entries. When a transaction inserts a tuple, the engine first flushes the tuple to NVM and records the non-volatile tuple pointer in a WAL entry. It then persists the log entry and marks the tuple as persisted. 
</code></pre></div></div>

<p>这里MemTable使用的是non-volatile  B+trees。(思考：这里不可变的memtable可以采用一个比B+tree更加省空间和有利于查找的数据结构，反正它是不可变的).</p>

<h5 id="recovery-5">Recovery</h5>

<p>只需要处理在MemTable中没有提交事务的数据就可以了，也只会有undo操作。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>During recovery, the NVM-Log engine only needs to undo the effects of uncommitted transactions on the MemTable. Its recovery latency is therefore lower than the Log engine as it no longer needs to rebuild the MemTable.
</code></pre></div></div>

<p>.</p>

<blockquote>

</blockquote>

<h3 id="评估">评估</h3>

<p>具体的性能数据查看论文[1].</p>

<blockquote>

</blockquote>

<h2 id="参考">参考</h2>

<ol>
  <li>Let’s Talk About Storage &amp; Recovery Methods for Non-Volatile Memory Database Systems, SIGMOD’15.</li>
</ol>

</span></div>
</div>


      </div>

      <div class="tile is-4 is-child">
        <div class="tile is-parent is-vertical sidebar">

          <div class="tile is-child widget">

            <div class="card">
              <header class="card-header">
                <p class="card-header-title nice-title">
                  Recent Posts
                </p>
              </header>
              <div class="card-content">
                <div class="content nice-text">
                  <ul>
                  
                  <li><a href="/2018/10/LegoOS.html">
                    LegoOS -- A Disseminated, Distributed OS for Hardware Resource Disaggregation
                  </a></li>
                  
                  <li><a href="/2018/10/Level-Hashing.html">
                    Write-Optimized and High-Performance Hashing Index Scheme for Persistent Memory
                  </a></li>
                  
                  <li><a href="/2018/10/Classical-Papers.html">
                    计算机科学经典论文
                  </a></li>
                  
                  </ul>
                </div>
              </div>
            </div>
          </div>

          <div class="tile is-child widget">

            <div class="card">
              <header class="card-header">
                <p class="card-header-title nice-title">
                  Sponsored
                </p>
              </header>
              <div class="card-content">
                <div class="content nice-text">
                  <img src="/assets/images/Dust_Bunny.jpg"/>
                </div>
              </div>
            </div>

          </div>

          <div class="tile is-child widget">
            <div class="card">
              <header class="card-header">
                <p class="card-header-title nice-title">
                  Recommended Websites
                </p>
              </header>
              <!-- <div class="card-content">
                <div class="content nice-text">
                  <ul>
                    <li>
                      <a href="https://xkcd.com">xkcd</a>
                    </li>
                    <li>
                      <a href="http://commitstrip.com">Commit Strip</a>
                    </li>
                    <li>
                      <a href="http://www.smbc-comics.com">SMBC Comics</a>
                    </li>
                    <li>
                      <a href="https://blog.codinghorror.com">Coding Horror</a>
                    </li>
                    <li>
                      <a href="http://waitbutwhy.com">Wait Buy Why</a>
                    </li>
                    <li>
                      <a href="https://simplysoch.wordpress.com/">Simply Soch</a>
                    </li>
                  </ul>
                </div> -->
              </div>
            </div>
          </div>

        </div>

      </div>

    </div>

  </div>
</div>

<footer class="footer">
  <div class="container">
    <div class="content has-text-centered">
      <p>
        Some rights reserved.
      </p>
      <p>
        Made with <i class="fa fa-heart"></i> and <a href="https://github.com/jgthms/bulma">Bulma</a>, <a href="https://jekyllrb.com/">Jekyll</a>. Hosted on <a href="https://github.com/">Github</a>
      </p>
      <p>
        <a class="icon" href="">
          <i class="fa fa-github" title="Github"></i>
        </a>
        <a class="icon" href="">
          <i class="fa fa-linkedin" title="Linkedin"></i>
        </a>
        <a class="icon" href="">
          <i class="fa fa-envelope" title="Email"></i>
        </a>
      </p>
    </div>
  </div>
</footer>

<!-- js -->
<script src="/assets/js/custom.js"></script>
<script src="/assets/js/typewriter.js"></script>
</body>
</html>
